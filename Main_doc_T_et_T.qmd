---
title: "Main Doc"
author: "Tommaso & Tony"
format: html
---

Part from Tommaso
## Types and classes

```{r}
typeof(1.5)
typeof("toto")
typeof(TRUE)
typeof(1L)
typeof(typeof)
typeof(list())
```



defines sets with associated operations. R or Z (integer number in mathematics). Types is the computer representation of this. everything is a double except if you . Characters:sequence of letters. Closure is a specific type for functions: don't excpext to be able to sum the functions between them for example. Most of those types have a hardware version on the CPU, It is what is give to you from the programming language There are differenece but we don't care. 


### Classes
classes in Python or R is the way to create your own type. 
```{r}
data(iris)
typeof(iris)
class(iris)
```
## Vectors
Many things in R are vectors (and most of the other things are lists).

A vector is a collection of values of the same type (possibly a single value).

```{r}
x <- 15.25
length(x) ##all vectors have a lenght 
x[1]
typeof(length(x))
length(length(x))
```


Part from Tony
## Indexing

Used to modify objects

```{r}
x <- c(1,2,3,4578)

x[2] <- x[4] - 4570

x
```

x is not y duh

```{r}
y <- x

x[3] <- 0

y 
x
```

Modifying x has no effect on y. y is a "lazy copy" : y is initialy x but whenever I modify y it creates a copy

Wattabout indexing by a vector ?

```{r}

x
x[c(2,2,1,4,3)] # displaying some values multiple times

# and if I do that ?

x[0] # gives an empty vector
x[7] # gives NA

# Thus

x[c(1,2,0,8)]

c(numeric(0), 5, numeric(0))

x[c(-1,-3)]

# Other possibilities

x[c(1,4)] <- c(2200,2202)
x
x[c(5,9)] <- c(2208,2222999)
x

```


Logical indexing 


```{r}

hidalgo <- c("Maire", "De", "Paris")
hidalgo
hidalgo[c(TRUE,FALSE,TRUE)]

```

Logical indexing 
```{r}
y <- c("A", "B","C")
y
y[c(TRUE, FALSE,TRUE)]
```

```{r}
x
x[c(1,4)] <- c(-34,42)
x
x[c(2,10)] <- c(123,78)
x
```

```{r}
y <- c("A", "B", "C")
y
y[c(TRUE, FALSE, TRUE)]
```


##Lists
Vectors must betype uniform, which will trigger a conversion to character in many cases.

```{r}
broken <- c(1L, 1.5, "toto(c'est moi excellent)", FALSE)
broken 
typeof(broken)
            
```
Lists do not have this limitation

### Creating a list

```{r}

bar <- list(1L, 1.5, "toto", FALSE)
bar
```


```{r}
typeof(bar)
length(bar)
```

```{r}
foo <- list(c(1,2,3), TRUE, length)
foo
length(foo)
```

### Indexing 

```{r}
foo
foo[1]
foo[-2]
foo[c(3,2,2,1)]
```

```{r}
foo[0]
```

### Side step: weird values
```{r}
NA ## missing value
NULL ## missing object
NaN ## Not a number
```

```{r}
0/0
1/0
-1/0
1/0-1/0
```

```{r}
NA_real_ +1
1/NA_real_
```

```{r}
NULL + 1